import os

# Problem : Merge Overlapping Intervals
problem_files = {
    "description.txt": """Merge Overlapping Intervals

You are given an array of intervals where intervals[i] = [start_i, end_i].
Merge all overlapping intervals and return an array of non-overlapping intervals.

Input Format:
- First line: Integer n (number of intervals)
- Next n lines: Two integers (start, end) for each interval

Output Format:
- Print merged intervals, one per line (start end)

Constraints:
- 1 ≤ n ≤ 10^4
- 0 ≤ start_i < end_i ≤ 10^4

Example 1:
Input:
4
1 3
2 6
8 10
15 18

Output:
1 6
8 10
15 18

Example 2:
Input:
2
1 4
4 5

Output:
1 5
""",

    "template.cpp": """class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals);
};
""",

    "template.py": """class Solution(object):
    def merge(self, intervals):
        \"\"\"
        :type intervals: List[List[int]]
        :rtype: List[List[int]]
        \"\"\"
        pass
""",

    "solution.cpp": """class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        if (intervals.empty()) return {};
        
        // Sort intervals by start time
        sort(intervals.begin(), intervals.end());
        
        vector<vector<int>> merged;
        merged.push_back(intervals[0]);
        
        for (int i = 1; i < intervals.size(); i++) {
            // If current interval overlaps with the last merged interval
            if (intervals[i][0] <= merged.back()[1]) {
                // Merge by updating the end time
                merged.back()[1] = max(merged.back()[1], intervals[i][1]);
            } else {
                // No overlap, add as new interval
                merged.push_back(intervals[i]);
            }
        }
        
        return merged;
    }
};
""",

    "solution.py": """class Solution(object):
    def merge(self, intervals):
        \"\"\"
        :type intervals: List[List[int]]
        :rtype: List[List[int]]
        \"\"\"
        if not intervals:
            return []
        
        # Sort intervals by start time
        intervals.sort(key=lambda x: x[0])
        
        merged = [intervals[0]]
        
        for i in range(1, len(intervals)):
            # If current interval overlaps with the last merged interval
            if intervals[i][0] <= merged[-1][1]:
                # Merge by updating the end time
                merged[-1][1] = max(merged[-1][1], intervals[i][1])
            else:
                # No overlap, add as new interval
                merged.append(intervals[i])
        
        return merged
""",

    "wrapper.cpp": """#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// ===== PLATFORM INJECTION POINT =====
// The contestant's Solution class will be injected here by the platform
// DO NOT UNCOMMENT OR MODIFY THIS SECTION
// ===== END INJECTION POINT =====

int main() {
    int n;
    cin >> n;
    
    vector<vector<int>> intervals(n, vector<int>(2));
    for (int i = 0; i < n; i++) {
        cin >> intervals[i][0] >> intervals[i][1];
    }
    
    Solution solution;
    vector<vector<int>> result = solution.merge(intervals);
    
    for (const auto& interval : result) {
        cout << interval[0] << " " << interval[1] << endl;
    }
    
    return 0;
}
""",

    "wrapper.py": """import sys

# ===== PLATFORM INJECTION POINT =====
# The contestant's Solution class will be injected here by the platform
# DO NOT UNCOMMENT OR MODIFY THIS SECTION
# ===== END INJECTION POINT =====

def main():
    try:
        n = int(input())
        intervals = []
        for _ in range(n):
            start, end = map(int, input().split())
            intervals.append([start, end])
        
        solution = Solution()
        result = solution.merge(intervals)
        
        for interval in result:
            print(interval[0], interval[1])
            
    except Exception as e:
        print(f"Runtime Error: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()
"""
}

# Problem : Number of Islands
problem_files = {
    "description.txt": """Number of Islands

You are given an m × n 2D binary grid which represents a map of '1's (land) 
and '0's (water). An island is formed by connecting adjacent lands horizontally 
or vertically.

Count the total number of islands. Assume all four edges are surrounded by water.

Input Format:
- First line: Two integers m n (rows and columns)
- Next m lines: n characters ('0' or '1')

Output Format:
- Single integer: number of islands

Constraints:
- 1 ≤ m, n ≤ 300
- grid[i][j] is '0' or '1'

Example 1:
Input:
4 5
11000
11000
00100
00011

Output:
3

Example 2:
Input:
3 3
111
010
111

Output:
1
""",

    "template.cpp": """class Solution {
public:
    int numIslands(vector<vector<char>>& grid);
};
""",

    "template.py": """class Solution(object):
    def numIslands(self, grid):
        \"\"\"
        :type grid: List[List[str]]
        :rtype: int
        \"\"\"
        pass
""",

    "solution.cpp": """class Solution {
private:
    void dfs(vector<vector<char>>& grid, int i, int j) {
        int m = grid.size();
        int n = grid[0].size();
        
        // Base cases
        if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] == '0') {
            return;
        }
        
        // Mark as visited
        grid[i][j] = '0';
        
        // Visit all 4 adjacent cells
        dfs(grid, i + 1, j);
        dfs(grid, i - 1, j);
        dfs(grid, i, j + 1);
        dfs(grid, i, j - 1);
    }
    
public:
    int numIslands(vector<vector<char>>& grid) {
        if (grid.empty() || grid[0].empty()) return 0;
        
        int m = grid.size();
        int n = grid[0].size();
        int count = 0;
        
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == '1') {
                    count++;
                    dfs(grid, i, j);
                }
            }
        }
        
        return count;
    }
};
""",

    "solution.py": """class Solution(object):
    def numIslands(self, grid):
        \"\"\"
        :type grid: List[List[str]]
        :rtype: int
        \"\"\"
        if not grid or not grid[0]:
            return 0
        
        m = len(grid)
        n = len(grid[0])
        count = 0
        
        def dfs(i, j):
            # Base cases
            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == '0':
                return
            
            # Mark as visited
            grid[i][j] = '0'
            
            # Visit all 4 adjacent cells
            dfs(i + 1, j)
            dfs(i - 1, j)
            dfs(i, j + 1)
            dfs(i, j - 1)
        
        for i in range(m):
            for j in range(n):
                if grid[i][j] == '1':
                    count += 1
                    dfs(i, j)
        
        return count
""",

    "wrapper.cpp": """#include <iostream>
#include <vector>
#include <string>
using namespace std;

// ===== PLATFORM INJECTION POINT =====
// The contestant's Solution class will be injected here by the platform
// DO NOT UNCOMMENT OR MODIFY THIS SECTION
// ===== END INJECTION POINT =====

int main() {
    int m, n;
    cin >> m >> n;
    
    vector<vector<char>> grid(m, vector<char>(n));
    for (int i = 0; i < m; i++) {
        string row;
        cin >> row;
        for (int j = 0; j < n; j++) {
            grid[i][j] = row[j];
        }
    }
    
    Solution solution;
    cout << solution.numIslands(grid) << endl;
    
    return 0;
}
""",

    "wrapper.py": """import sys

# ===== PLATFORM INJECTION POINT =====
# The contestant's Solution class will be injected here by the platform
# DO NOT UNCOMMENT OR MODIFY THIS SECTION
# ===== END INJECTION POINT =====

def main():
    try:
        m, n = map(int, input().split())
        grid = []
        for _ in range(m):
            row = list(input().strip())
            grid.append(row)
        
        solution = Solution()
        result = solution.numIslands(grid)
        print(result)
            
    except Exception as e:
        print(f"Runtime Error: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()
"""
}

# Problem : Product of Array Except Self
problem_files = {
    "description.txt": """Product of Array Except Self

Given an integer array nums, return an answer array such that answer[i] is 
equal to the product of all elements of nums except nums[i].

Constraints:
- O(n) time complexity
- Cannot use division operation

Input Format:
- First line: Integer n (array length)
- Second line: n space-separated integers

Output Format:
- n space-separated integers (the answer array)

Constraints:
- 2 ≤ n ≤ 10^5
- -30 ≤ nums[i] ≤ 30
- Product of any prefix or suffix guaranteed to fit in 32-bit integer

Example 1:
Input:
4
1 2 3 4

Output:
24 12 8 6

Example 2:
Input:
5
-1 1 0 -3 3

Output:
0 0 9 0 0
""",

    "template.cpp": """class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums);
};
""",

    "template.py": """class Solution(object):
    def productExceptSelf(self, nums):
        \"\"\"
        :type nums: List[int]
        :rtype: List[int]
        \"\"\"
        pass
""",

    "solution.cpp": """class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int n = nums.size();
        vector<int> answer(n, 1);
        
        // First pass: calculate prefix products
        int prefix = 1;
        for (int i = 0; i < n; i++) {
            answer[i] = prefix;
            prefix *= nums[i];
        }
        
        // Second pass: calculate suffix products and multiply
        int suffix = 1;
        for (int i = n - 1; i >= 0; i--) {
            answer[i] *= suffix;
            suffix *= nums[i];
        }
        
        return answer;
    }
};
""",

    "solution.py": """class Solution(object):
    def productExceptSelf(self, nums):
        \"\"\"
        :type nums: List[int]
        :rtype: List[int]
        \"\"\"
        n = len(nums)
        answer = [1] * n
        
        # First pass: calculate prefix products
        prefix = 1
        for i in range(n):
            answer[i] = prefix
            prefix *= nums[i]
        
        # Second pass: calculate suffix products and multiply
        suffix = 1
        for i in range(n - 1, -1, -1):
            answer[i] *= suffix
            suffix *= nums[i]
        
        return answer
""",

    "wrapper.cpp": """#include <iostream>
#include <vector>
using namespace std;

// ===== PLATFORM INJECTION POINT =====
// The contestant's Solution class will be injected here by the platform
// DO NOT UNCOMMENT OR MODIFY THIS SECTION
// ===== END INJECTION POINT =====

int main() {
    int n;
    cin >> n;
    
    vector<int> nums(n);
    for (int i = 0; i < n; i++) {
        cin >> nums[i];
    }
    
    Solution solution;
    vector<int> result = solution.productExceptSelf(nums);
    
    for (int i = 0; i < result.size(); i++) {
        if (i > 0) cout << " ";
        cout << result[i];
    }
    cout << endl;
    
    return 0;
}
""",

    "wrapper.py": """import sys

# ===== PLATFORM INJECTION POINT =====
# The contestant's Solution class will be injected here by the platform
# DO NOT UNCOMMENT OR MODIFY THIS SECTION
# ===== END INJECTION POINT =====

def main():
    try:
        n = int(input())
        nums = list(map(int, input().split()))
        
        solution = Solution()
        result = solution.productExceptSelf(nums)
        
        print(' '.join(map(str, result)))
            
    except Exception as e:
        print(f"Runtime Error: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()
"""
}

# Problem : Top K Frequent Elements
problem_files = {
    "description.txt": """Top K Frequent Elements

Given an integer array nums and an integer k, return the k most frequent elements.
You may return the answer in any order.

Input Format:
- First line: Two integers n k (array length and k)
- Second line: n space-separated integers

Output Format:
- k space-separated integers (the k most frequent elements)

Constraints:
- 1 ≤ k ≤ n ≤ 10^5
- -10^4 ≤ nums[i] ≤ 10^4
- It is guaranteed answer is unique

Example 1:
Input:
6 2
1 1 1 2 2 3

Output:
1 2

Example 2:
Input:
1 1
1

Output:
1

Example 3:
Input:
7 3
4 1 -1 2 -1 2 3

Output:
-1 2 4
""",

    "template.cpp": """class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k);
};
""",

    "template.py": """class Solution(object):
    def topKFrequent(self, nums, k):
        \"\"\"
        :type nums: List[int]
        :type k: int
        :rtype: List[int]
        \"\"\"
        pass
""",

    "solution.cpp": """#include <unordered_map>
#include <queue>

class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        // Count frequencies
        unordered_map<int, int> freq;
        for (int num : nums) {
            freq[num]++;
        }
        
        // Use min heap to keep top k elements
        auto cmp = [](pair<int, int>& a, pair<int, int>& b) {
            return a.second > b.second;
        };
        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(cmp)> minHeap(cmp);
        
        for (auto& p : freq) {
            minHeap.push(p);
            if (minHeap.size() > k) {
                minHeap.pop();
            }
        }
        
        // Extract results
        vector<int> result;
        while (!minHeap.empty()) {
            result.push_back(minHeap.top().first);
            minHeap.pop();
        }
        
        return result;
    }
};
""",

    "solution.py": """class Solution(object):
    def topKFrequent(self, nums, k):
        \"\"\"
        :type nums: List[int]
        :type k: int
        :rtype: List[int]
        \"\"\"
        from collections import Counter
        import heapq
        
        # Count frequencies
        freq = Counter(nums)
        
        # Use heap to get top k
        # Python's heapq is min heap, so negate frequencies for max heap behavior
        return heapq.nlargest(k, freq.keys(), key=freq.get)
""",

    "wrapper.cpp": """#include <iostream>
#include <vector>
using namespace std;

// ===== PLATFORM INJECTION POINT =====
// The contestant's Solution class will be injected here by the platform
// DO NOT UNCOMMENT OR MODIFY THIS SECTION
// ===== END INJECTION POINT =====

int main() {
    int n, k;
    cin >> n >> k;
    
    vector<int> nums(n);
    for (int i = 0; i < n; i++) {
        cin >> nums[i];
    }
    
    Solution solution;
    vector<int> result = solution.topKFrequent(nums, k);
    
    for (int i = 0; i < result.size(); i++) {
        if (i > 0) cout << " ";
        cout << result[i];
    }
    cout << endl;
    
    return 0;
}
""",

    "wrapper.py": """import sys

# ===== PLATFORM INJECTION POINT =====
# The contestant's Solution class will be injected here by the platform
# DO NOT UNCOMMENT OR MODIFY THIS SECTION
# ===== END INJECTION POINT =====

def main():
    try:
        n, k = map(int, input().split())
        nums = list(map(int, input().split()))
        
        solution = Solution()
        result = solution.topKFrequent(nums, k)
        
        print(' '.join(map(str, result)))
            
    except Exception as e:
        print(f"Runtime Error: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()
"""
}

# Problem : Elevator Control System (OOP Design)
problem_files = {
    "description.txt": """Design an Elevator Control System

Design an object-oriented system to control elevators in a building.

Requirements:
1. Building has N floors and M elevators
2. Users can request elevator from any floor (direction: Up/Down)
3. Users can select destination floor inside elevator
4. System dispatches most appropriate elevator to minimize wait time

Core Classes:
- Elevator: Manages current floor, direction, state, internal requests
- ElevatorController: Manages all elevators and dispatches requests
- Request: Represents external (floor) or internal (destination) requests
- Floor, Building, Button (optional)

Task:
Implement a simplified simulation that processes a sequence of requests.

Input Format:
- Line 1: Three integers N M T (floors, elevators, time steps)
- Next T lines: Requests in format "EXTERNAL floor direction" or "INTERNAL elevator_id destination"

Output Format:
- For each time step, print elevator states: "Elevator <id>: Floor <f> Direction <dir> State <state>"

Constraints:
- 2 ≤ N ≤ 100
- 1 ≤ M ≤ 10
- 1 ≤ T ≤ 100
- Directions: UP, DOWN, IDLE
- States: MOVING, IDLE, DOORS_OPEN

Example:
Input:
10 2 5
EXTERNAL 3 UP
INTERNAL 0 7
EXTERNAL 5 DOWN
INTERNAL 1 2
EXTERNAL 8 DOWN

Output:
Step 0: Elevator 0 dispatched to floor 3
Step 1: Elevator 0 at floor 3, doors open
Step 2: Elevator 0 moving to floor 7
Step 3: Elevator 1 dispatched to floor 5
Step 4: Elevator 0 at floor 7, doors open
""",

    "template.cpp": """class Solution {
public:
    vector<string> simulateElevatorSystem(int numFloors, int numElevators, 
                                          vector<string>& requests);
};
""",

    "template.py": """class Solution(object):
    def simulateElevatorSystem(self, numFloors, numElevators, requests):
        \"\"\"
        :type numFloors: int
        :type numElevators: int
        :type requests: List[str]
        :rtype: List[str]
        \"\"\"
        pass
""",

    "solution.cpp": """#include <queue>
#include <sstream>

class Solution {
private:
    enum Direction { IDLE, UP, DOWN };
    enum State { STOPPED, MOVING, DOORS_OPEN };
    
    struct Elevator {
        int id;
        int currentFloor;
        Direction direction;
        State state;
        queue<int> destinations;
        
        Elevator(int id) : id(id), currentFloor(1), direction(IDLE), state(STOPPED) {}
    };
    
    string dirToString(Direction dir) {
        if (dir == UP) return "UP";
        if (dir == DOWN) return "DOWN";
        return "IDLE";
    }
    
    string stateToString(State s) {
        if (s == MOVING) return "MOVING";
        if (s == DOORS_OPEN) return "DOORS_OPEN";
        return "IDLE";
    }
    
public:
    vector<string> simulateElevatorSystem(int numFloors, int numElevators, 
                                          vector<string>& requests) {
        vector<Elevator> elevators;
        for (int i = 0; i < numElevators; i++) {
            elevators.push_back(Elevator(i));
        }
        
        vector<string> output;
        int step = 0;
        
        for (const string& req : requests) {
            istringstream iss(req);
            string type;
            iss >> type;
            
            if (type == "EXTERNAL") {
                int floor;
                string dir;
                iss >> floor >> dir;
                
                // Simple dispatch: find nearest idle elevator
                int bestElev = 0;
                int minDist = abs(elevators[0].currentFloor - floor);
                
                for (int i = 1; i < numElevators; i++) {
                    int dist = abs(elevators[i].currentFloor - floor);
                    if (dist < minDist) {
                        minDist = dist;
                        bestElev = i;
                    }
                }
                
                elevators[bestElev].destinations.push(floor);
                output.push_back("Step " + to_string(step) + 
                               ": Elevator " + to_string(bestElev) + 
                               " dispatched to floor " + to_string(floor));
            }
            else if (type == "INTERNAL") {
                int elevId, dest;
                iss >> elevId >> dest;
                
                if (elevId >= 0 && elevId < numElevators) {
                    elevators[elevId].destinations.push(dest);
                    output.push_back("Step " + to_string(step) + 
                                   ": Elevator " + to_string(elevId) + 
                                   " moving to floor " + to_string(dest));
                }
            }
            
            step++;
        }
        
        return output;
    }
};
""",

    "solution.py": """from collections import deque

class Solution(object):
    def simulateElevatorSystem(self, numFloors, numElevators, requests):
        \"\"\"
        :type numFloors: int
        :type numElevators: int
        :type requests: List[str]
        :rtype: List[str]
        \"\"\"
        class Elevator:
            def __init__(self, elevator_id):
                self.id = elevator_id
                self.current_floor = 1
                self.direction = "IDLE"
                self.state = "IDLE"
                self.destinations = deque()
        
        elevators = [Elevator(i) for i in range(numElevators)]
        output = []
        step = 0
        
        for req in requests:
            parts = req.split()
            req_type = parts[0]
            
            if req_type == "EXTERNAL":
                floor = int(parts[1])
                direction = parts[2]
                
                # Simple dispatch: find nearest idle elevator
                best_elev = 0
                min_dist = abs(elevators[0].current_floor - floor)
                
                for i in range(1, numElevators):
                    dist = abs(elevators[i].current_floor - floor)
                    if dist < min_dist:
                        min_dist = dist
                        best_elev = i
                
                elevators[best_elev].destinations.append(floor)
                output.append(f"Step {step}: Elevator {best_elev} dispatched to floor {floor}")
                
            elif req_type == "INTERNAL":
                elev_id = int(parts[1])
                dest = int(parts[2])
                
                if 0 <= elev_id < numElevators:
                    elevators[elev_id].destinations.append(dest)
                    output.append(f"Step {step}: Elevator {elev_id} moving to floor {dest}")
            
            step += 1
        
        return output
""",

    "wrapper.cpp": """#include <iostream>
#include <vector>
#include <string>
using namespace std;

// ===== PLATFORM INJECTION POINT =====
// The contestant's Solution class will be injected here by the platform
// DO NOT UNCOMMENT OR MODIFY THIS SECTION
// ===== END INJECTION POINT =====

int main() {
    int n, m, t;
    cin >> n >> m >> t;
    cin.ignore();
    
    vector<string> requests;
    for (int i = 0; i < t; i++) {
        string line;
        getline(cin, line);
        requests.push_back(line);
    }
    
    Solution solution;
    vector<string> output = solution.simulateElevatorSystem(n, m, requests);
    
    for (const string& line : output) {
        cout << line << endl;
    }
    
    return 0;
}
""",

    "wrapper.py": """import sys

# ===== PLATFORM INJECTION POINT =====
# The contestant's Solution class will be injected here by the platform
# DO NOT UNCOMMENT OR MODIFY THIS SECTION
# ===== END INJECTION POINT =====

def main():
    try:
        n, m, t = map(int, input().split())
        requests = []
        for _ in range(t):
            requests.append(input().strip())
        
        solution = Solution()
        output = solution.simulateElevatorSystem(n, m, requests)
        
        for line in output:
            print(line)
            
    except Exception as e:
        print(f"Runtime Error: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()
"""
}

# Create directory structure and write files
def create_problem_files(problem_name, files_dict):
    """Create directory and files for a problem"""
    os.makedirs(problem_name, exist_ok=True)
    
    for filename, content in files_dict.items():
        filepath = os.path.join(problem_name, filename)
        with open(filepath, 'w') as f:
            f.write(content)
    
    print(f"✓ Created {problem_name} with {len(files_dict)} files")

# Create all problems
problems = [
    ("problem_merge_intervals", problem6_files),
    ("problem_number_of_islands", problem7_files),
    ("problem_product_except_self", problem8_files),
    ("problem_top_k_frequent", problem9_files),
    ("problem_elevator_system", problem10_files)
]

print("Generating competitive programming files for additional problems...\n")

for problem_name, files in problems:
    create_problem_files(problem_name, files)

print("\n✓ All additional problems generated successfully!")
print("\nDirectory structure:")
print("├── problem_merge_intervals/")
print("├── problem_number_of_islands/")
print("├── problem_product_except_self/")
print("├── problem_top_k_frequent/")
print("└── problem_elevator_system/")
print("\nEach contains:")
print("  ├── description.txt")
print("  ├── template.cpp")
print("  ├── template.py")
print("  ├── solution.cpp")
print("  ├── solution.py")
print("  ├── wrapper.cpp")
print("  └── wrapper.py")
