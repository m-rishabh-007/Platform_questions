problem - 1
# ========== description.txt ==========
"""
Balanced Brackets

Determine if a string containing brackets ()[]{}  is valid:
1. Open brackets must be closed by the same type
2. Open brackets must be closed in correct order
3. Every close bracket has a corresponding open bracket

Input Format:
- Single line: string containing only ()[]{}

Output Format:
- "true" if balanced, "false" otherwise

Constraints:
- 0 <= string length <= 10000

Examples:
- "()[]{}" → true
- "([)]" → false
- "{[]}" → true
- "" → true
"""

# ========== template.cpp ==========
"""
#include <string>

class Solution {
public:
    bool areBracketsBalanced(const std::string& s) {
        // Your code here
        return false;
    }
};
"""

# ========== template.py ==========
"""
class Solution:
    def areBracketsBalanced(self, s):
        """
        :type s: str
        :rtype: bool
        """
        # Your code here
        return False
"""

# ========== solution.cpp ==========
"""
#include <string>
#include <stack>
#include <map>

class Solution {
public:
    bool areBracketsBalanced(const std::string& s) {
        std::stack<char> st;
        std::map<char, char> bracket_map;
        bracket_map[')'] = '(';
        bracket_map['}'] = '{';
        bracket_map[']'] = '[';

        for (int i = 0; i < s.length(); ++i) {
            char c = s[i];
            if (bracket_map.find(c) == bracket_map.end()) {
                st.push(c);
            } else {
                if (st.empty() || st.top() != bracket_map[c]) {
                    return false;
                }
                st.pop();
            }
        }
        return st.empty();
    }
};
"""

# ========== solution.py ==========
"""
class Solution:
    def areBracketsBalanced(self, s):
        stack = []
        bracket_map = {")": "(", "}": "{", "]": "["}
        
        for char in s:
            if char in bracket_map:
                top_element = stack.pop() if stack else '#'
                if bracket_map[char] != top_element:
                    return False
            else:
                stack.append(char)
                
        return not stack
"""

# ========== wrapper.cpp ==========
"""
#include <iostream>
#include <string>

// ===== PLATFORM INJECTION POINT =====
// The contestant's Solution class will be injected here by the platform
// DO NOT UNCOMMENT OR MODIFY THIS SECTION
// ===== END INJECTION POINT =====

int main() {
    std::string s;
    std::cin >> s;
    
    Solution sol;
    if (sol.areBracketsBalanced(s)) {
        std::cout << "true" << std::endl;
    } else {
        std::cout << "false" << std::endl;
    }
    
    return 0;
}
"""

# ========== wrapper.py ==========
"""
import sys

# ===== PLATFORM INJECTION POINT =====
# The contestant's Solution class will be injected here by the platform
# DO NOT UNCOMMENT OR MODIFY THIS SECTION
# ===== END INJECTION POINT =====

def execute_solution():
    try:
        s = input().strip()
        
        solution = Solution()
        result = solution.areBracketsBalanced(s)
        
        print("true" if result else "false")
        
    except Exception as e:
        print(f"Runtime Error: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    execute_solution()
"""

problem - 2
# ========== description.txt ==========
"""
Directory Tree Lister

Given a file system as a nested dictionary, print a visual tree. Directories (dict values) end with '/', files are None. Items at each level are alphabetically sorted with 2-space indentation per level.

Input Format:
- Single line: JSON string representing file system

Output Format:
- Multi-line tree with 2-space indentation per level

Constraints:
- Maximum depth: 10
- Names: letters, numbers, underscores, periods only
- Maximum 50 items per directory

Example:
Input:
{"docs": {"report.txt": null}, "src": {"main.py": null, "utils": {"helpers.py": null}}, "readme.md": null}

Output:
docs/
  report.txt
readme.md
src/
  main.py
  utils/
    helpers.py
"""

# ========== template.cpp ==========
"""
#include <string>
#include <map>

struct FileNode {
    std::map<std::string, FileNode*> children;
    bool is_directory;
};

class Solution {
public:
    void printTree(FileNode* root) {
        // Your code here
    }
};
"""

# ========== template.py ==========
"""
class Solution:
    def listDirectoryTree(self, fs):
        """
        :type fs: dict
        :rtype: None (prints to stdout)
        """
        # Your code here
        pass
"""

# ========== solution.cpp ==========
"""
#include <string>
#include <map>
#include <vector>
#include <algorithm>
#include <iostream>

struct FileNode {
    std::map<std::string, FileNode*> children;
    bool is_directory;
};

class Solution {
public:
    void printTree(FileNode* root) {
        if (!root) return;
        _printRecursive(root, 0);
    }

private:
    void _printRecursive(FileNode* node, int depth) {
        std::vector<std::string> keys;
        for (auto it = node->children.begin(); it != node->children.end(); ++it) {
            keys.push_back(it->first);
        }
        std::sort(keys.begin(), keys.end());

        for (size_t i = 0; i < keys.size(); ++i) {
            std::string key = keys[i];
            FileNode* child = node->children[key];
            
            for (int d = 0; d < depth; ++d) {
                std::cout << "  ";
            }

            std::cout << key;
            if (child->is_directory) {
                std::cout << "/" << std::endl;
                _printRecursive(child, depth + 1);
            } else {
                std::cout << std::endl;
            }
        }
    }
};
"""

# ========== solution.py ==========
"""
class Solution:
    def listDirectoryTree(self, fs):
        self._print_recursive(fs, 0)
    
    def _print_recursive(self, node, depth):
        sorted_keys = sorted(node.keys())
        
        for key in sorted_keys:
            print('  ' * depth + key, end='')
            
            value = node[key]
            if isinstance(value, dict):
                print('/')
                self._print_recursive(value, depth + 1)
            else:
                print()
"""

# ========== wrapper.cpp ==========
"""
#include <iostream>
#include <string>
#include <map>
#include <vector>
#include <sstream>

// ===== PLATFORM INJECTION POINT =====
// The contestant's Solution class will be injected here by the platform
// DO NOT UNCOMMENT OR MODIFY THIS SECTION
// ===== END INJECTION POINT =====

// Simple JSON parser for this specific problem
FileNode* parseJSON(const std::string& json, size_t& pos);

FileNode* parseObject(const std::string& json, size_t& pos) {
    FileNode* node = new FileNode{{}, true};
    pos++; // skip '{'
    
    while (pos < json.length() && json[pos] != '}') {
        while (pos < json.length() && (json[pos] == ' ' || json[pos] == '\n' || json[pos] == ',')) pos++;
        if (json[pos] == '}') break;
        
        pos++; // skip '"'
        std::string key;
        while (json[pos] != '"') {
            key += json[pos++];
        }
        pos++; // skip '"'
        
        while (pos < json.length() && (json[pos] == ' ' || json[pos] == ':')) pos++;
        
        if (json[pos] == '{') {
            node->children[key] = parseObject(json, pos);
        } else if (json[pos] == 'n') {
            node->children[key] = new FileNode{{}, false};
            pos += 4; // skip "null"
        }
    }
    pos++; // skip '}'
    return node;
}

int main() {
    std::string json;
    std::getline(std::cin, json);
    
    size_t pos = 0;
    FileNode* root = parseObject(json, pos);
    
    Solution sol;
    sol.printTree(root);
    
    return 0;
}
"""

# ========== wrapper.py ==========
"""
import sys
import json

# ===== PLATFORM INJECTION POINT =====
# The contestant's Solution class will be injected here by the platform
# DO NOT UNCOMMENT OR MODIFY THIS SECTION
# ===== END INJECTION POINT =====

def execute_solution():
    try:
        fs_json = input().strip()
        fs = json.loads(fs_json)
        
        solution = Solution()
        solution.listDirectoryTree(fs)
        
    except Exception as e:
        print(f"Runtime Error: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    execute_solution()
"""
problem - 3
# ========== description.txt ==========
"""
Matrix Spiral Traversal

Traverse a matrix in spiral order: right → down → left → up, continuing inward.

Input Format:
- Line 1: Two space-separated integers m (rows) and n (columns)
- Next m lines: n space-separated integers per row

Output Format:
- Single line of space-separated integers in spiral order

Constraints:
- 1 <= m, n <= 100
- -1000 <= matrix values <= 1000

Example:
Input:
3 4
1 2 3 4
5 6 7 8
9 10 11 12

Output:
1 2 3 4 8 12 11 10 9 5 6 7
"""

# ========== template.cpp ==========
"""
#include <vector>

class Solution {
public:
    std::vector<int> spiralOrder(const std::vector<std::vector<int>>& matrix) {
        std::vector<int> result;
        // Your code here
        return result;
    }
};
"""

# ========== template.py ==========
"""
class Solution:
    def spiralOrder(self, matrix):
        """
        :type matrix: List[List[int]]
        :rtype: List[int]
        """
        # Your code here
        return []
"""

# ========== solution.cpp ==========
"""
#include <vector>

class Solution {
public:
    std::vector<int> spiralOrder(const std::vector<std::vector<int>>& matrix) {
        std::vector<int> result;
        if (matrix.empty() || matrix[0].empty()) return result;

        int m = matrix.size();
        int n = matrix[0].size();
        int top = 0, bottom = m - 1, left = 0, right = n - 1;

        while (top <= bottom && left <= right) {
            for (int j = left; j <= right; ++j) {
                result.push_back(matrix[top][j]);
            }
            top++;

            for (int i = top; i <= bottom; ++i) {
                result.push_back(matrix[i][right]);
            }
            right--;

            if (top <= bottom) {
                for (int j = right; j >= left; --j) {
                    result.push_back(matrix[bottom][j]);
                }
                bottom--;
            }

            if (left <= right) {
                for (int i = bottom; i >= top; --i) {
                    result.push_back(matrix[i][left]);
                }
                left++;
            }
        }
        return result;
    }
};
"""

# ========== solution.py ==========
"""
class Solution:
    def spiralOrder(self, matrix):
        if not matrix or not matrix[0]:
            return []
        
        result = []
        m, n = len(matrix), len(matrix[0])
        top, bottom, left, right = 0, m - 1, 0, n - 1

        while top <= bottom and left <= right:
            for j in range(left, right + 1):
                result.append(matrix[top][j])
            top += 1

            for i in range(top, bottom + 1):
                result.append(matrix[i][right])
            right -= 1

            if top <= bottom:
                for j in range(right, left - 1, -1):
                    result.append(matrix[bottom][j])
                bottom -= 1

            if left <= right:
                for i in range(bottom, top - 1, -1):
                    result.append(matrix[i][left])
                left += 1
                
        return result
"""

# ========== wrapper.cpp ==========
"""
#include <iostream>
#include <vector>

// ===== PLATFORM INJECTION POINT =====
// The contestant's Solution class will be injected here by the platform
// DO NOT UNCOMMENT OR MODIFY THIS SECTION
// ===== END INJECTION POINT =====

int main() {
    int m, n;
    std::cin >> m >> n;
    std::vector<std::vector<int>> matrix(m, std::vector<int>(n));
    
    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            std::cin >> matrix[i][j];
        }
    }

    Solution sol;
    std::vector<int> result = sol.spiralOrder(matrix);
    
    for (size_t i = 0; i < result.size(); ++i) {
        std::cout << result[i];
        if (i < result.size() - 1) std::cout << " ";
    }
    std::cout << std::endl;

    return 0;
}
"""

# ========== wrapper.py ==========
"""
import sys

# ===== PLATFORM INJECTION POINT =====
# The contestant's Solution class will be injected here by the platform
# DO NOT UNCOMMENT OR MODIFY THIS SECTION
# ===== END INJECTION POINT =====

def execute_solution():
    try:
        m, n = map(int, input().strip().split())
        matrix = []
        for _ in range(m):
            row = list(map(int, input().strip().split()))
            matrix.append(row)
        
        solution = Solution()
        result = solution.spiralOrder(matrix)
        
        print(' '.join(map(str, result)))
        
    except Exception as e:
        print(f"Runtime Error: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    execute_solution()
"""
problem - 4
# ========== description.txt ==========
"""
Minimum Sum of Products

Given two arrays A and B where len(B) <= len(A), select a subset of A with the same size as B.
Pair elements from the subset with B to minimize the sum of products.

Strategy: Sort both arrays. Select the smallest elements from A. Pair smallest from A-subset with largest from B.

Input Format:
- Line 1: Space-separated integers for array A
- Line 2: Space-separated integers for array B

Output Format:
- Single integer: minimum possible sum of products

Constraints:
- 1 <= len(B) <= len(A) <= 1000
- -1000 <= array values <= 1000

Example:
Input:
-10 -5 0 8 12
-20 15

Output:
-50

Explanation:
A sorted: [-10, -5, 0, 8, 12]
B sorted: [-20, 15]
Select smallest 2 from A: [-10, -5]
Pair: (-10 * 15) + (-5 * -20) = -150 + 100 = -50
"""

# ========== template.cpp ==========
"""
#include <vector>

class Solution {
public:
    long long minSumOfProducts(std::vector<int>& A, std::vector<int>& B) {
        // Your code here
        return 0;
    }
};
"""

# ========== template.py ==========
"""
class Solution:
    def minSumOfProducts(self, A, B):
        """
        :type A: List[int]
        :type B: List[int]
        :rtype: int
        """
        # Your code here
        return 0
"""

# ========== solution.cpp ==========
"""
#include <vector>
#include <algorithm>

class Solution {
public:
    long long minSumOfProducts(std::vector<int>& A, std::vector<int>& B) {
        std::sort(A.begin(), A.end());
        std::sort(B.begin(), B.end());

        long long min_sum = 0;
        int n = B.size();

        for (int i = 0; i < n; ++i) {
            min_sum += (long long)A[i] * B[n - 1 - i];
        }
        return min_sum;
    }
};
"""

# ========== solution.py ==========
"""
class Solution:
    def minSumOfProducts(self, A, B):
        A.sort()
        B.sort()
        
        n = len(B)
        A_sub = A[:n]
        
        min_sum = 0
        for i in range(n):
            min_sum += A_sub[i] * B[n - 1 - i]
            
        return min_sum
"""

# ========== wrapper.cpp ==========
"""
#include <iostream>
#include <vector>
#include <string>
#include <sstream>

// ===== PLATFORM INJECTION POINT =====
// The contestant's Solution class will be injected here by the platform
// DO NOT UNCOMMENT OR MODIFY THIS SECTION
// ===== END INJECTION POINT =====

void readVector(std::vector<int>& vec) {
    std::string line;
    std::getline(std::cin, line);
    std::stringstream ss(line);
    int num;
    while (ss >> num) {
        vec.push_back(num);
    }
}

int main() {
    std::vector<int> A, B;
    readVector(A);
    readVector(B);
    
    Solution sol;
    std::cout << sol.minSumOfProducts(A, B) << std::endl;
    
    return 0;
}
"""

# ========== wrapper.py ==========
"""
import sys

# ===== PLATFORM INJECTION POINT =====
# The contestant's Solution class will be injected here by the platform
# DO NOT UNCOMMENT OR MODIFY THIS SECTION
# ===== END INJECTION POINT =====

def execute_solution():
    try:
        A = list(map(int, input().strip().split()))
        B = list(map(int, input().strip().split()))
        
        solution = Solution()
        result = solution.minSumOfProducts(A, B)
        
        print(result)
        
    except Exception as e:
        print(f"Runtime Error: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    execute_solution()
"""
problem - 5
# ========== description.txt ==========
"""
Multi-Class Library System

Design a simple command-line library management system with three classes: Book, Member, and Library. 
The Library class is the main interface supporting:
- Adding books and members
- Checking out books
- Returning books
- Tracking availability

Input Format:
- ADD BOOK "<title>" "<author>": Adds a new book
- ADD MEMBER "<name>" <id>: Registers a new member
- CHECKOUT <member_id> "<book_title>": Member checks out a book
- RETURN "<book_title>": Returns a book
- EXIT: Terminates the program

Output Format:
- ADD BOOK: Book "<title>" added.
- ADD MEMBER: Member "<name>" registered.
- CHECKOUT: Checkout successful. | Error: Book not available. | Error: Member not found. | Error: Book not found.
- RETURN: Return successful. | Error: Book not in records or was not checked out.

Constraints:
- 1 <= Number of commands <= 200
- 1 <= length of names/titles <= 100
- 1 <= member_id <= 1000
- Book titles and names are enclosed in double quotes
- A book can only be checked out by one member at a time

Example:
Input:
ADD BOOK "Dune" "Frank Herbert"
ADD MEMBER "Bob" 101
CHECKOUT 101 "Dune"
CHECKOUT 101 "Dune"
RETURN "Dune"
EXIT

Output:
Book "Dune" added.
Member "Bob" registered.
Checkout successful.
Error: Book not available.
Return successful.
"""

# ========== template.cpp ==========
"""
#include <string>
#include <map>

class Book {
public:
    std::string title;
    std::string author;
    bool is_checked_out;
    int checked_out_by;

    Book(std::string t, std::string a);
};

class Member {
public:
    std::string name;
    int member_id;

    Member(std::string n, int id);
};

class Library {
private:
    std::map<std::string, Book*> books;
    std::map<int, Member*> members;

public:
    void addBook(const std::string& title, const std::string& author);
    void addMember(const std::string& name, int id);
    void checkoutBook(int member_id, const std::string& title);
    void returnBook(const std::string& title);
};
"""

# ========== template.py ==========
"""
class Book:
    def __init__(self, title, author):
        pass

class Member:
    def __init__(self, name, member_id):
        pass

class Library:
    def __init__(self):
        pass

    def addBook(self, title, author):
        pass

    def addMember(self, name, member_id):
        pass

    def checkoutBook(self, member_id, title):
        pass

    def returnBook(self, title):
        pass
"""

# ========== solution.cpp ==========
"""
#include <string>
#include <map>
#include <iostream>

class Book {
public:
    std::string title;
    std::string author;
    bool is_checked_out;
    int checked_out_by;

    Book(std::string t, std::string a) : title(t), author(a), is_checked_out(false), checked_out_by(-1) {}
};

class Member {
public:
    std::string name;
    int member_id;

    Member(std::string n, int id) : name(n), member_id(id) {}
};

class Library {
private:
    std::map<std::string, Book*> books;
    std::map<int, Member*> members;

public:
    ~Library() {
        for (auto& pair : books) {
            delete pair.second;
        }
        for (auto& pair : members) {
            delete pair.second;
        }
    }

    void addBook(const std::string& title, const std::string& author) {
        if (books.find(title) == books.end()) {
            books[title] = new Book(title, author);
            std::cout << "Book \"" << title << "\" added." << std::endl;
        }
    }

    void addMember(const std::string& name, int id) {
        if (members.find(id) == members.end()) {
            members[id] = new Member(name, id);
            std::cout << "Member \"" << name << "\" registered." << std::endl;
        }
    }

    void checkoutBook(int member_id, const std::string& title) {
        if (members.find(member_id) == members.end()) {
            std::cout << "Error: Member not found." << std::endl;
            return;
        }
        if (books.find(title) == books.end()) {
            std::cout << "Error: Book not found." << std::endl;
            return;
        }
        if (books[title]->is_checked_out) {
            std::cout << "Error: Book not available." << std::endl;
        } else {
            books[title]->is_checked_out = true;
            books[title]->checked_out_by = member_id;
            std::cout << "Checkout successful." << std::endl;
        }
    }

    void returnBook(const std::string& title) {
        if (books.find(title) == books.end() || !books[title]->is_checked_out) {
            std::cout << "Error: Book not in records or was not checked out." << std::endl;
        } else {
            books[title]->is_checked_out = false;
            books[title]->checked_out_by = -1;
            std::cout << "Return successful." << std::endl;
        }
    }
};
"""

# ========== solution.py ==========
"""
class Book:
    def __init__(self, title, author):
        self.title = title
        self.author = author
        self.is_checked_out = False
        self.checked_out_by = None

class Member:
    def __init__(self, name, member_id):
        self.name = name
        self.member_id = int(member_id)

class Library:
    def __init__(self):
        self.books = {}
        self.members = {}

    def addBook(self, title, author):
        if title not in self.books:
            self.books[title] = Book(title, author)
            print(f'Book "{title}" added.')

    def addMember(self, name, member_id):
        member_id = int(member_id)
        if member_id not in self.members:
            self.members[member_id] = Member(name, member_id)
            print(f'Member "{name}" registered.')

    def checkoutBook(self, member_id, title):
        member_id = int(member_id)
        if member_id not in self.members:
            print("Error: Member not found.")
            return
        if title not in self.books:
            print("Error: Book not found.")
            return
        
        book = self.books[title]
        if book.is_checked_out:
            print("Error: Book not available.")
        else:
            book.is_checked_out = True
            book.checked_out_by = member_id
            print("Checkout successful.")

    def returnBook(self, title):
        if title not in self.books or not self.books[title].is_checked_out:
            print("Error: Book not in records or was not checked out.")
        else:
            self.books[title].is_checked_out = False
            self.books[title].checked_out_by = None
            print("Return successful.")
"""

# ========== wrapper.cpp ==========
"""
#include <iostream>
#include <string>
#include <sstream>

// ===== PLATFORM INJECTION POINT =====
// The contestant's Solution classes will be injected here by the platform
// DO NOT UNCOMMENT OR MODIFY THIS SECTION
// ===== END INJECTION POINT =====

std::string parseQuoted(std::stringstream& ss) {
    std::string temp, result;
    ss >> std::ws;
    std::getline(ss, temp, '"');
    std::getline(ss, result, '"');
    return result;
}

int main() {
    Library library;
    std::string line;
    
    while (std::getline(std::cin, line) && line != "EXIT") {
        std::stringstream ss(line);
        std::string command;
        ss >> command;

        if (command == "ADD") {
            ss >> command;
            if (command == "BOOK") {
                std::string title = parseQuoted(ss);
                std::string author = parseQuoted(ss);
                library.addBook(title, author);
            } else if (command == "MEMBER") {
                std::string name = parseQuoted(ss);
                int id;
                ss >> id;
                library.addMember(name, id);
            }
        } else if (command == "CHECKOUT") {
            int member_id;
            ss >> member_id;
            std::string title = parseQuoted(ss);
            library.checkoutBook(member_id, title);
        } else if (command == "RETURN") {
            std::string title = parseQuoted(ss);
            library.returnBook(title);
        }
    }
    
    return 0;
}
"""

# ========== wrapper.py ==========
"""
import sys

# ===== PLATFORM INJECTION POINT =====
# The contestant's Solution classes will be injected here by the platform
# DO NOT UNCOMMENT OR MODIFY THIS SECTION
# ===== END INJECTION POINT =====

def parse_line(line):
    parts = []
    in_quote = False
    current_part = ""
    for char in line:
        if char == '"':
            in_quote = not in_quote
        elif char == ' ' and not in_quote:
            if current_part:
                parts.append(current_part)
                current_part = ""
        else:
            current_part += char
    if current_part:
        parts.append(current_part)
    return parts

def execute_solution():
    try:
        library = Library()
        for line in sys.stdin:
            line = line.strip()
            if line == "EXIT":
                break
            
            parts = parse_line(line)
            command = parts[0]
            
            if command == "ADD" and parts[1] == "BOOK":
                library.addBook(parts[2], parts[3])
            elif command == "ADD" and parts[1] == "MEMBER":
                library.addMember(parts[2], parts[3])
            elif command == "CHECKOUT":
                library.checkoutBook(parts[1], parts[2])
            elif command == "RETURN":
                library.returnBook(parts[1])
                
    except Exception as e:
        print(f"Runtime Error: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    execute_solution()
"""
