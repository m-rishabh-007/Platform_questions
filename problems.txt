Of course\! Here are five intermediate-level questions structured according to your specified difficulties and categories.

-----

### 1\. Sorting (Easy Level)

**Problem: Merge Overlapping Intervals**

You are given an array of intervals where `intervals[i] = [start_i, end_i]`. Your task is to merge all overlapping intervals and return an array of the non-overlapping intervals that cover all the intervals in the input.

**Example:**

  * **Input:** `intervals = [[1,3],[2,6],[8,10],[15,18]]`
  * **Output:** `[[1,6],[8,10],[15,18]]`
  * **Explanation:** Since intervals `[1,3]` and `[2,6]` overlap, they are merged into `[1,6]`.

**Why it's a good question:** This is a classic problem that perfectly tests if a candidate understands that sorting is often a prerequisite for solving more complex problems. The core insight is to sort the intervals by their starting points.

-----

### 2\. DSA (Medium Level)

**Problem: Number of Islands** üèùÔ∏è

You are given an $m \times n$ 2D binary grid `grid` which represents a map of `'1'`s (land) and `'0'`s (water). An island is formed by connecting adjacent lands horizontally or vertically.

Your task is to count the total number of islands. You can assume all four edges of the grid are surrounded by water.

**Example:**

  * **Input:**
    ```
    grid = [
      ["1","1","0","0","0"],
      ["1","1","0","0","0"],
      ["0","0","1","0","0"],
      ["0","0","0","1","1"]
    ]
    ```
  * **Output:** `3`

**Why it's a good question:** This is a fundamental graph traversal problem disguised in a matrix. It's a perfect test of a candidate's ability to implement **Depth-First Search (DFS)** or **Breadth-First Search (BFS)** to explore and mark visited nodes in an implicit graph.

-----

### 3\. Logic (Medium Level)

**Problem: Product of Array Except Self**

You are given an integer array `nums`. Your task is to return an answer array `answer` such that `answer[i]` is equal to the product of all the elements of `nums` except `nums[i]`.

**Constraints:**

  * You must write an algorithm that runs in $O(n)$ time.
  * You **cannot** use the division operation.

**Example:**

  * **Input:** `nums = [1, 2, 3, 4]`
  * **Output:** `[24, 12, 8, 6]`
  * **Explanation:**
      * `answer[0]` = 2 \* 3 \* 4 = 24
      * `answer[1]` = 1 \* 3 \* 4 = 12
      * `answer[2]` = 1 \* 2 \* 4 = 8
      * `answer[3]` = 1 \* 2 \* 3 = 6

**Why it's a good question:** This is a brilliant logic puzzle. The constraints force the candidate to avoid the obvious brute-force or division-based solutions. The optimal solution requires a clever two-pass approach using prefix and suffix products, testing pure algorithmic thinking.

-----

### 4\. DSA (Medium Level)

**Problem: Top K Frequent Elements**

You are given an integer array `nums` and an integer `k`. Your task is to return the `k` most frequent elements. You may return the answer in any order.

**Example:**

  * **Input:** `nums = [1,1,1,2,2,3]`, `k = 2`
  * **Output:** `[1,2]`
  * **Explanation:** The number `1` appears 3 times, `2` appears 2 times, and `3` appears once. The two most frequent are `1` and `2`.

**Why it's a good question:** This problem requires a combination of data structures to solve efficiently. The standard solution involves using a **Hash Map** to count frequencies and then a **Min-Heap** (Priority Queue) to keep track of the `k` most frequent elements, making it an excellent test of multi-structure implementation.

-----

### 5\. OOP (Hard Level)

**Problem: Design an Elevator Control System** üè¢

Design an object-oriented system to control a set of elevators in a building.

**Core Requirements:**

1.  The building has `N` floors and `M` elevators.
2.  Users can request an elevator from any floor to go in a specific direction (Up/Down).
3.  Once inside an elevator, a user can select a destination floor.
4.  The system must have a central controller that dispatches the most appropriate elevator to a request to minimize wait time and travel time.

**Your Task:**
Describe the main classes, their properties (attributes), and their methods. Explain how these classes would interact to handle a user request from start to finish (e.g., a user on Floor 3 presses the 'UP' button, an elevator arrives, the user gets in and selects Floor 10).

**Key Classes to Consider:**

  * `Elevator`: Manages its current floor, direction, state (moving, idle, doors\_open), and internal requests.
  * `ElevatorController` (or `Dispatcher`): Manages all elevators and external floor requests, implementing the dispatching logic.
  * `Request`: Can represent an external request (from a floor) or an internal request (from inside an elevator).
  * `Floor`, `Building`, `Button`, etc.

**Why it's a good question:** This is a challenging design problem that goes beyond simple class creation. It tests a candidate's ability to model a complex, stateful system. A good answer will involve thinking about **encapsulation** (e.g., `ElevatorController` doesn't need to know the internal mechanics of an `Elevator`), **state management** (elevator's direction and status), and **strategy** (the algorithm used by the controller to choose an elevator).
